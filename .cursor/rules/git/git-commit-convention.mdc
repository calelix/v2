---
alwaysApply: true
---

Git Commit Convention

> 최신 업데이트: 2026년 01월 30일 01:30

# Git 커밋 작성 규칙

## 커밋 철학

좋은 커밋은 **"무엇을 왜 했는지"**를 명확히 전달합니다.
- **무엇을**: 커밋 제목에서 간결하게
- **왜**: 커밋 본문에서 상세하게 (선택적이지만 강력 권장)

## 커밋 메시지 형식

```
<타입>: <무엇을 했는지>

<왜 했는지 - 배경, 이유, 목적 설명>
<선택적: 관련 이슈, 참고사항>
```

### 예시

```
feat: JWT 기반 인증 시스템 구현

기존 세션 기반 인증의 서버 부하 문제를 해결하고,
마이크로서비스 아키텍처에서 stateless 인증을 지원하기 위해
JWT 토큰 기반 인증을 도입했습니다.
```

## 타입 (Type)

- **feat** - 새로운 기능 추가
- **fix** - 버그 수정
- **refactor** - 코드 리팩토링 (기능 변경 없이 구조 개선)
- **test** - 테스트 코드 추가/수정
- **style** - 코드 스타일 변경 (포맷팅, 세미콜론 등)
- **docs** - 프로젝트 문서 변경 (README, 주석 등)
- **build** - 빌드 시스템 변경 (webpack, npm scripts 등)
- **ci** - CI/CD 설정 변경
- **revert** - 변경 사항 되돌리기
- **content** - 사용자에게 보이는 콘텐츠 문서 수정 (블로그, 이미지, 텍스트 등)
- **chore** - 위 타입에 해당하지 않는 기타 작업 (의존성 추가/업데이트, 개발 환경 설정 등)

---

# 커밋 자동 생성 가이드

사용자가 **"커밋을 생성하라"** 등의 요청을 하면 다음 프로세스를 따라 자동으로 논리적으로 분리된 커밋들을 생성합니다.

## 사용자와의 상호작용

### 자동 분석 모드 (기본)

사용자가 명령만 하면 AI가 자동으로:
1. 변경사항 분석
2. 논리적 그룹 판단
3. 적절한 커밋 메시지 작성
4. 순차적 커밋 생성

### 확인 모드 (사용자가 신중한 경우)

사용자가 "커밋 전에 확인하고 싶다" 등의 요청을 하면:
1. 분석 결과와 커밋 계획을 먼저 보여줌
2. 사용자 승인 후 실행

### 예시 출력

```
변경사항을 분석했습니다. 다음과 같이 5개의 커밋으로 분리하겠습니다:

1. feat: JWT 기반 인증 시스템 구현
   - auth/jwt.ts
   - auth/middleware.ts
   이유: stateless 인증 지원

2. feat: 로그인 API 엔드포인트 추가
   - api/login.ts
   이유: 로그인 기능 구현

3. refactor: 버튼 컴포넌트 재사용성 개선
   - components/Button.tsx
   - components/Input.tsx
   이유: 중복 코드 제거

4. fix: 로그인 폼 버그 수정
   - pages/login.tsx
   - utils/validator.ts
   이유: null 입력 시 크래시 해결

5. docs: 설치 가이드 추가
   - README.md
   이유: 온보딩 개선

진행할까요? (또는 자동 진행)
```

## 핵심 원칙

1. **NEVER** 모든 변경사항을 한 번에 `git add .` 하지 말 것
2. **ALWAYS** 변경사항을 논리적 단위로 분석하고 그룹화
3. 각 커밋은 **독립적으로 의미있고 빌드 가능**해야 함
4. 커밋 순서는 **의존성을 고려** (유틸 → 그것을 사용하는 컴포넌트)
5. 각 커밋 메시지에 **"왜"를 명확히 기술**

## 커밋 생성 프로세스

### 1단계: 변경사항 전체 분석

다음 명령어들을 병렬로 실행하여 정보를 수집:

```bash
# 변경된 파일 목록
git status

# 파일별 변경사항 통계
git diff --stat

# 상세 변경내용 (파일별로)
git diff
```

### 2단계: 논리적 그룹핑

변경사항을 분석하여 다음 기준으로 그룹화:

#### 그룹 분리 기준

1. **목적이 다른 경우**
   - 예: 버그 수정 vs 새 기능 추가 → 별도 커밋

2. **타입이 다른 경우**
   - 예: `refactor` vs `feat` → 별도 커밋

3. **독립적인 기능/영역**
   - 예: 인증 로직 vs UI 컴포넌트 → 별도 커밋
   - 예: 데이터베이스 마이그레이션 vs API 엔드포인트 → 별도 커밋

4. **영향 범위가 다른 경우**
   - 예: 프론트엔드 vs 백엔드 → 별도 커밋

5. **시간적 독립성**
   - 예: 리팩토링 후 기능 추가 → 리팩토링을 먼저 커밋

#### 그룹핑 예시

10개 파일이 변경된 경우:

```
변경됨: package.json             → 그룹 A (chore: 라이브러리 추가)
변경됨: pnpm-lock.yaml           → 그룹 A (chore: 라이브러리 추가)
변경됨: auth/jwt.ts              → 그룹 B (feat: JWT 구현)
변경됨: auth/middleware.ts       → 그룹 B (feat: JWT 구현)
변경됨: api/login.ts             → 그룹 C (feat: 로그인 API)
변경됨: api/signup.ts            → 그룹 D (feat: 회원가입 API)
변경됨: components/Button.tsx    → 그룹 E (refactor: 공통 컴포넌트)
변경됨: components/Input.tsx     → 그룹 E (refactor: 공통 컴포넌트)
변경됨: pages/login.tsx          → 그룹 F (fix: 로그인 버그)
변경됨: utils/validator.ts       → 그룹 F (fix: 로그인 버그)
변경됨: styles/theme.ts          → 그룹 G (style: 테마 업데이트)
변경됨: README.md                → 그룹 H (docs: 문서 추가)
```

결과: **8개의 독립적인 커밋** 생성

**주의:** 의존성 추가(그룹 A)는 해당 기능 구현(그룹 B) 직전에 커밋하여 의존성 순서를 유지합니다.

### 3단계: 파일 단위 커밋 생성

각 그룹마다 순차적으로 커밋 생성:

```bash
# 그룹 A: JWT 구현
git add auth/jwt.ts auth/middleware.ts
git commit -m "$(cat <<'EOF'
feat: JWT 기반 인증 시스템 구현

기존 세션 기반 인증의 서버 부하 문제를 해결하고,
stateless 인증을 지원하기 위해 JWT를 도입했습니다.
EOF
)"

# 그룹 B: 로그인 API
git add api/login.ts
git commit -m "$(cat <<'EOF'
feat: 로그인 API 엔드포인트 추가

JWT 인증을 사용하는 로그인 엔드포인트를 구현했습니다.
EOF
)"

# 그룹 C: 회원가입 API
git add api/signup.ts
git commit -m "$(cat <<'EOF'
feat: 회원가입 API 엔드포인트 추가

이메일 중복 검증과 비밀번호 해싱을 포함한
회원가입 로직을 구현했습니다.
EOF
)"

# ... 나머지 그룹들도 동일하게
```

### 4단계: 같은 파일 내 라인 단위 커밋 분리 (고급)

**하나의 파일에서 서로 다른 목적의 변경사항이 있는 경우**, 라인 단위로 분리 가능:

#### 상황 예시

`auth/user.ts` 파일에서:
- 라인 10-20: 버그 수정 (null 체크 추가)
- 라인 50-60: 새 기능 추가 (프로필 조회)

#### 분리 방법 1: 임시 파일 활용 (권장)

```bash
# 원본 백업
cp auth/user.ts auth/user.ts.full

# 1. 버그 수정만 적용한 버전 생성
# (라인 50-60을 원래대로 되돌림)
git checkout HEAD -- auth/user.ts
# 수동으로 라인 10-20만 수정하거나 StrReplace 사용
git add auth/user.ts
git commit -m "fix: 로그인 null 체크 추가

null 입력 시 크래시 발생 버그를 수정했습니다."

# 2. 전체 버전으로 복원
cp auth/user.ts.full auth/user.ts

# 3. 이제 라인 50-60만 스테이징됨
git add auth/user.ts
git commit -m "feat: 사용자 프로필 조회 기능 추가

사용자 ID로 프로필을 조회하는 기능을 추가했습니다."

# 정리
rm auth/user.ts.full
```

#### 분리 방법 2: Git Patch 활용

```bash
# 변경사항을 패치 파일로 저장
git diff auth/user.ts > user.patch

# 원본으로 리셋
git checkout HEAD -- auth/user.ts

# 패치 파일을 수동으로 편집하여 일부만 적용
# (라인 10-20 관련 hunk만 남기고 나머지 삭제)
git apply user-part1.patch
git add auth/user.ts
git commit -m "fix: ..."

# 나머지 적용
git apply user-part2.patch
git add auth/user.ts
git commit -m "feat: ..."
```

#### 주의사항

- 라인 단위 분리는 **복잡도가 높으므로** 정말 필요한 경우만 사용
- **파일 단위 분리를 우선**으로 고려
- 분리된 각 커밋이 **빌드 가능하고 테스트 통과**하는지 확인
- 라인이 서로 **의존성이 없는지** 확인

### 5단계: 커밋 순서 최적화

의존성을 고려한 순서로 커밋:

1. **외부 의존성 추가** (package.json 등) - 제일 먼저
2. **유틸리티/공통 함수**
3. **타입/인터페이스** 정의
4. **비즈니스 로직** 구현
5. **UI 컴포넌트** (로직 사용)
6. **페이지/라우트** (컴포넌트 사용)
7. **테스트 코드**
8. **문서/스타일** 마지막

예시:

```bash
1. chore: JWT 관련 라이브러리 추가
2. feat: 인증 유틸리티 함수 추가
3. feat: 사용자 타입 정의
4. feat: JWT 인증 로직 구현
5. feat: 로그인 컴포넌트 추가
6. feat: 로그인 페이지 구현
7. test: 로그인 플로우 테스트 추가
8. docs: 인증 사용법 문서 추가
```

### 6단계: 커밋 완료 후 확인

```bash
# 커밋 목록 확인
git log --oneline -n 10

# 각 커밋의 변경사항 확인
git show HEAD
git show HEAD~1
```

## 특수 상황 처리

### 머지 충돌이 있는 경우

```bash
# 충돌 확인
git status

# 사용자에게 알림
"머지 충돌이 감지되었습니다. 충돌을 해결한 후 다시 시도해주세요."
```

### 커밋할 변경사항이 없는 경우

```bash
git status
# "nothing to commit, working tree clean"

# 사용자에게 알림
"커밋할 변경사항이 없습니다."
```

### 브랜치가 분기되지 않은 경우

변경사항이 있어도 main 브랜치에서 작업 중이면:
```
"현재 main 브랜치에서 작업 중입니다. 
새 브랜치를 생성하시겠습니까? (feature/xxx)"
```

## 커밋 메시지 품질 체크리스트

각 커밋 메시지 작성 시 다음을 확인:

- [ ] 제목은 50자 이내
- [ ] 제목은 명령형 (예: "Add" not "Added")
- [ ] 타입이 명확함 (feat, fix, refactor 등)
- [ ] "무엇을"이 명확함
- [ ] 본문에 "왜"가 설명됨 (중요한 변경사항인 경우)
- [ ] 빌드 가능한 상태
- [ ] 하나의 논리적 변경사항만 포함

## 추가 참고사항

### 커밋 크기

- **너무 큰 커밋**: 여러 목적이 섞여있지 않은지 재검토
- **너무 작은 커밋**: 의미있는 단위인지 확인

### 커밋 타이밍

- 리팩토링은 **기능 추가 전에** 별도 커밋
- 버그 수정은 **발견 즉시** 별도 커밋
- 테스트는 구현과 **함께 또는 직후** 커밋

### 되돌리기

잘못된 커밋을 만들었다면:
```bash
# 마지막 커밋 취소 (변경사항은 유지)
git reset --soft HEAD~1

# 다시 그룹핑하여 커밋
```
