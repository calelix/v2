---
alwaysApply: true
---

Integration Testing Guide

> 최신 업데이트: 2026년 01월 29일 01:30

# Integration 테스트 가이드

컴포넌트와 로직을 통합하여 사용자 관점으로 테스트

---

# 정의

**Integration 테스트:**
- 컴포넌트 + 로직 + 상태를 통합하여 테스트
- 사용자 관점에서 상호작용 검증
- 실제 사용 환경과 유사한 가상 DOM 환경
- 프론트엔드 테스트의 핵심 전략 (약 90%)

**특징:**
- 실행 속도: 빠름
- 테스트 환경: 가상 DOM (jsdom)
- 범위: 컴포넌트 + 자식 + 상태 + 이벤트

**철학:**
> "The more your tests resemble the way your software is used, the more confidence they can give you." - React Testing Library

사용자가 하는 방식으로 테스트하되, 구현 세부사항(Implementation Detail)은 무시하고 접근성을 우선한다.

---

# 언제 사용하는가

## Integration 테스트가 적합한 경우

프론트엔드 컴포넌트 테스트의 기본 선택지이다. 대부분의 경우에 해당한다.

### 일반적인 컴포넌트
- Form, List, Table, Card 등 대부분의 UI 컴포넌트
- 상태와 UI가 결합된 컴포넌트

### 사용자 상호작용
- 클릭, 입력, 선택 등 단일 동작
- 여러 동작의 조합 (입력 후 클릭, 선택 후 제출 등)

### 조건부 렌더링
- loading/success/error 등 상태별 UI 변화
- 권한이나 조건에 따른 UI 표시/숨김

### 상태 관리와 UI
- useState, useReducer를 사용하는 컴포넌트
- Context를 통한 전역 상태 관리

### API 통합
- fetch, axios 등 API 호출과 응답에 따른 UI 변화
- 외부 API는 모킹하여 테스트

---

## Integration 테스트가 부적합한 경우

### 순수 로직만 있는 경우
UI 없이 독립적인 로직은 Unit 테스트로 분리

### 브라우저 전용 기능
Portal, Focus trap, IntersectionObserver 등은 Browser 테스트

### 여러 페이지 플로우
전체 사용자 여정은 E2E 테스트

### Wrapper 컴포넌트
children 전달이나 className 병합만 하는 컴포넌트는 테스트 불필요

---

# 테스트 대상

## 1. 사용자 상호작용

사용자가 수행하는 동작과 그에 따른 결과를 검증한다.

**검증 항목:**
- 버튼 클릭 시 의도한 동작 수행
- Input 입력 시 값 반영
- Form 제출 시 처리 로직 실행
- 드롭다운, 체크박스 등 선택 시 상태 변경

---

## 2. 상태 변화와 UI 반영

컴포넌트 내부 상태나 외부에서 주입된 상태가 변경될 때 UI가 올바르게 업데이트되는지 검증한다.

**검증 항목:**
- loading → success 전환
- loading → error 전환
- empty state → data loaded
- 조건부 렌더링이 의도대로 동작

---

## 3. 비즈니스 로직

컴포넌트에 포함된 비즈니스 규칙이 UI에 올바르게 반영되는지 검증한다.

**검증 항목:**
- Validation 규칙 적용 (이메일 형식, 필수 입력 등)
- 권한 기반 UI (관리자만 보이는 버튼 등)
- 계산 결과 표시 (합계, 할인율 등)
- 상태에 따른 버튼 활성화/비활성화

---

## 4. 접근성

키보드 사용자, 스크린 리더 사용자도 컴포넌트를 사용할 수 있는지 검증한다.

**검증 항목:**
- 키보드 네비게이션 (Tab, Enter, Space)
- ARIA 속성의 적절한 사용
- Focus 관리 (모달 오픈 시 focus 이동 등)
- Label과 Input의 올바른 연결

---

## 5. Edge Case

예외적인 상황에서도 컴포넌트가 안정적으로 동작하는지 검증한다.

**검증 항목:**
- 빈 상태 (empty state)
- 에러 상태
- Loading 상태
- null/undefined 처리
- 권한 없음 상태
- 네트워크 오류

---

# 테스트 작성 원칙

## 1. 사용자 관점으로 테스트

내부 구현이 아닌 외부에서 관찰 가능한 동작을 검증한다.

**테스트하지 말 것:**
- State 변수 확인
- Props 확인
- 내부 함수 호출

**테스트할 것:**
- 사용자가 보는 것
- 사용자가 하는 동작
- 결과로 나타나는 변화

---

## 2. Implementation Detail 무시

구현 세부사항에 의존하면 리팩토링 시 테스트가 깨진다. 외부 동작만 검증한다.

**테스트하지 말 것:**
- State 변수 이름
- 함수 호출 순서나 횟수
- 렌더링 횟수
- CSS 클래스명
- 내부 DOM 구조

**테스트할 것:**
- 외부에서 관찰 가능한 동작
- 사용자가 경험하는 최종 결과

---

## 3. 접근성 우선

접근성을 고려한 쿼리를 우선 사용하면 자연스럽게 접근성이 개선된다.

**원칙:**
- role 쿼리 우선 사용
- ARIA 속성 활용
- 키보드 접근성 테스트 포함
- 스크린 리더 사용자 관점 고려

---

## 4. 적절한 통합 범위

너무 작게 쪼개지 말고, 의미 있는 단위로 통합하여 테스트한다.

**테스트 범위:**
- 단일 컴포넌트 + 자식 컴포넌트들
- 관련된 Custom Hook들
- 상태 관리 로직

**분리하지 말 것:**
- 너무 작은 단위로 쪼개기
- 자식 컴포넌트를 개별적으로 테스트
- 통합 시 발생하는 문제를 놓칠 수 있음

---

## 5. 독립성

각 테스트는 독립적으로 실행 가능해야 한다.

**원칙:**
- 각 테스트마다 새로운 렌더링
- 실행 순서에 무관
- 공유 상태 없음

---

## 6. 명확성

테스트 이름과 구조가 의도를 명확히 드러내야 한다.

**권장 구조:**
- Given-When-Then
- Given: 컴포넌트 렌더링, 초기 상태 설정, Mock 설정
- When: 사용자 동작 시뮬레이션, 이벤트 발생
- Then: UI 변화 확인, 상태 반영 확인, 콜백 호출 확인

---

# 모킹 전략

## 최소 모킹 원칙

Integration 테스트는 가능한 실제 구현을 사용하되, 외부 의존성만 모킹한다.

**모킹할 것:**
- 외부 API (fetch, axios)
- 브라우저 API (localStorage, geolocation)
- 시간, 랜덤 값

**모킹하지 말 것:**
- 내부 로직
- 자식 컴포넌트
- Custom Hook (UI와 결합된 경우)

---

## API 모킹

**방법:**
- vi.fn(): 간단한 함수 모킹
- MSW (Mock Service Worker): 네트워크 레벨 모킹 (권장)
  - 실제 HTTP 요청을 intercept
  - 실제 API와 동일한 구조로 응답

**원칙:**
- 실제 API 구조와 동일하게 모킹
- Happy path와 Error case 모두 테스트
- Loading 상태 포함

---

## Context/Provider 모킹

**방법:**
- Custom render 함수 작성
- 테스트에 필요한 Provider로 컴포넌트 감싸기
- 필요한 값을 주입

**원칙:**
- 실제 Provider를 사용 (모킹하지 않음)
- 테스트별로 다른 초기 상태 설정

---

## 외부 라이브러리 모킹

**모킹이 필요한 경우:**
- 브라우저 API 의존 (localStorage, navigator 등)
- 랜덤 값 생성 (UUID 등)
- 시간 의존 (Date, setTimeout 등)

**방법:**
- vi.mock(): 모듈 전체 모킹
- vi.spyOn(): 특정 메서드만 모킹

---

# 특수 케이스

## Compound Components

여러 서브 컴포넌트가 Context로 연결된 복합 컴포넌트의 경우, 전체를 통합하여 테스트한다.

**전략:**
- 개별 서브 컴포넌트를 따로 테스트하지 않음
- 전체 조합을 하나로 테스트
- Context 기반 상태 공유를 통합 검증

---

## Custom Hooks (UI 의존)

UI와 결합된 Custom Hook은 별도로 테스트하지 않고 사용처에서 통합 테스트한다.

**전략:**
- Hook을 사용하는 컴포넌트에서 테스트
- Hook 단독 테스트는 불필요
- 실제 사용 시나리오 검증

---

## Form 컴포넌트

Form은 전체 플로우를 통합하여 테스트한다.

**전략:**
- 입력 → 검증 → 제출의 전체 플로우
- 개별 field를 따로 테스트하지 않음
- 여러 field 간의 상호작용 포함

---

## Modal/Dialog

Modal의 내부 로직만 Integration 테스트하고, Portal이나 Focus trap 등 브라우저 기능은 Browser 테스트로 분리한다.

**전략:**
- 내부 컨텐츠와 상호작용은 Integration
- Portal 렌더링, Focus trap은 Browser 테스트

---

# 안티패턴

## 피해야 할 것

### 1. Wrapper 컴포넌트 테스트

children 전달, className 적용, props 전달만 하는 컴포넌트는 테스트가 의미 없다. 구현을 그대로 복사하는 것에 불과하다.

### 2. Snapshot 테스트

Snapshot 테스트는 의미 없는 변경에도 실패하고, Diff를 읽기 어려우며, 실제 버그를 놓치기 쉽다. 구체적인 assertion을 사용하거나 Visual regression 도구(Chromatic 등)를 활용한다.

### 3. Implementation Detail 테스트

State 변수, 함수 호출 횟수, 내부 구조에 의존하면 리팩토링 시 테스트가 깨지고 유지보수가 어려워진다.

### 4. 과도한 모킹

내부 로직까지 모킹하면 실제와 동떨어진 테스트가 되어 통합 테스트의 의미를 상실한다. 외부 의존성만 모킹하고 내부 로직은 실제 구현을 사용한다.

### 5. testId 남용

testId는 접근성을 무시하고 의미 없는 속성을 추가하는 것이다. role 쿼리를 우선 사용하고, testId는 정말 다른 방법이 없을 때만 최후의 수단으로 사용한다.

---

# 커버리지 목표

**권장 커버리지:**
- 주요 사용자 플로우: 100%
- 상태 변화: 100%
- 조건부 렌더링: 100%
- 에러 케이스: 90%+
- Edge cases: 80%+

**주의:**
- Wrapper 컴포넌트는 제외
- 의미 있는 테스트에 집중
- 커버리지는 수단이지 목적이 아님

---
---
---

# 라이브러리 사용 가이드

아래는 Vitest와 Testing Library 사용 시 참고할 구체적인 API 가이드이다.

---

## Testing Library 쿼리 우선순위

### 1순위: 접근성 기반 쿼리 (권장)

**getByRole**
- 가장 권장되는 쿼리
- 접근성을 자동으로 검증
- 스크린 리더 사용자 관점
- 예: `getByRole('button', { name: '제출' })`

**getByLabelText**
- Form 요소 검색
- label과 input의 연결 검증
- 예: `getByLabelText('이메일')`

**getByPlaceholderText**
- Input의 placeholder로 검색
- 예: `getByPlaceholderText('이메일을 입력하세요')`

**getByText**
- 보이는 텍스트로 검색
- 예: `getByText('환영합니다')`

### 2순위: Semantic 쿼리

**getByAltText**
- 이미지의 alt 속성으로 검색
- 예: `getByAltText('프로필 사진')`

**getByTitle**
- title 속성으로 검색
- 예: `getByTitle('닫기')`

### 최후의 수단: getByTestId

다른 방법이 모두 불가능할 때만 사용한다.

**사용 시기:**
- 동적으로 생성되는 콘텐츠
- 텍스트가 자주 변경되는 경우
- 예: `getByTestId('submit-button')`

**주의:**
- 남용 금지
- 접근성 쿼리를 먼저 고려

---

## user-event vs fireEvent

### user-event (권장)

실제 사용자 동작을 시뮬레이션한다. 여러 이벤트를 조합하여 더 현실적인 테스트가 가능하다.

**특징:**
- 비동기 동작 (await 필요)
- 여러 이벤트 조합 (예: click은 mousedown + mouseup + click)
- 더 현실적인 시뮬레이션

**사용 예:**
```typescript
await user.click(button)
await user.type(input, 'hello')
await user.selectOptions(select, 'option1')
```

### fireEvent (비권장)

단순히 이벤트를 발생시킨다. user-event로 불가능한 경우에만 사용한다.

**특징:**
- 동기적
- 하나의 이벤트만 발생

**사용 예:**
```typescript
fireEvent.change(input, { target: { value: 'hello' } })
```

---

## 비동기 처리

### waitFor

비동기 상태 변화를 기다린다.

**사용:**
```typescript
await waitFor(() => {
  expect(screen.getByText('완료')).toBeInTheDocument()
})
```

**원칙:**
- 구체적인 조건 명시
- 필요시 timeout 설정: `waitFor(() => {...}, { timeout: 3000 })`

### findBy 쿼리

자동으로 waitFor를 포함한다. 요소가 나타날 때까지 대기한다.

**사용:**
```typescript
const element = await screen.findByText('완료')
```

**적합한 경우:**
- 비동기 렌더링
- API 응답 후 UI 업데이트

### act

React 상태 업데이트를 감싸는 유틸리티. user-event는 내부적으로 act를 처리하므로 직접 사용할 일은 거의 없다.

**사용 시기:**
- 직접 state를 변경하는 경우에만
- user-event 사용 시 불필요

---

## 접근성 테스트

### axe-core (vitest-axe)

자동으로 접근성 규칙을 검증하는 도구.

**사용:**
```typescript
import { axe, toHaveNoViolations } from 'vitest-axe'

expect.extend(toHaveNoViolations)

test('접근성 검증', async () => {
  const { container } = render(<Component />)
  const results = await axe(container)
  expect(results).toHaveNoViolations()
})
```

### 수동 체크리스트

자동화 도구로 검증할 수 없는 항목들을 수동으로 확인한다.

- [ ] 키보드만으로 모든 기능 사용 가능
- [ ] Tab 순서가 논리적
- [ ] Focus 표시가 명확
- [ ] ARIA 속성이 적절히 사용됨
- [ ] Label과 Input이 올바르게 연결됨
- [ ] 에러 메시지가 명확히 전달됨
- [ ] Loading 상태가 스크린 리더에 공지됨
